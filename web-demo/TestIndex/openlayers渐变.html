
<!DOCTYPE html>
<html>
<head>
    <title>OpenLayers+高德地图动态渐变圆</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol/ol.css">
    <style>
        #map {
            width: 100%;
            height: 100vh;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <script src="https://cdn.jsdelivr.net/npm/ol@10.5.0/dist/ol.min.js"></script>
    <script>
        // 高德地图瓦片服务
        const gaodeLayer = new ol.layer.Tile({
            source: new ol.source.XYZ({
                url: 'https://webst0{1-4}.is.autonavi.com/appmaptile?x={x}&y={y}&z={z}&lang=zh_cn&size=1&scale=1&style=7'
            })
        });

        const map = new ol.Map({
            target: 'map',
            layers: [gaodeLayer],
            view: new ol.View({
                center: ol.proj.fromLonLat([116.4, 39.9]),
                zoom: 10
            })
        });

        // 动态渐变圆参数
        let currentRadius = 0;
        let growing = true;
        const maxRadius = 3000; // 单位：米

        // 创建Canvas渐变样式
        function createGradientStyle() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(0, 0, 0, 200, 300, currentRadius);
            
            // gradient.addColorStop(0, 'rgba(0,255,255,0.8)');
            // gradient.addColorStop(0.5, 'rgba(0,0,200,0.5)');
            // gradient.addColorStop(1, 'rgba(0,0,255,0.2)');
            // gradient.addColorStop(0, 'red');
            // gradient.addColorStop(1, 'blue');
            gradient.addColorStop(0, "rgba(255,255,0,0)");
            gradient.addColorStop(0.3, "rgba(255,0,0,0.5)");
            gradient.addColorStop(1, "rgba(255,0,0,1)");
            return new ol.style.Style({
                image: new ol.style.Circle({
                    radius: currentRadius / map.getView().getResolution(),
                    fill: new ol.style.Fill({ color: gradient }),
                    stroke: new ol.style.Stroke({
                        color: 'rgba(255,255,255,0.8)',
                        width: 2
                    })
                })
            });
        }

        // 矢量图层
        const vectorLayer = new ol.layer.Vector({
            source: new ol.source.Vector({
                features: [new ol.Feature({
                    geometry: new ol.geom.Point(ol.proj.fromLonLat([116.4, 39.9]))
                })]
            }),
            style: createGradientStyle
        });


        // 米转像素的转换函数
        const metersToPixels = (meters, resolution) => {
            return meters / (resolution * 39.37 * 0.0254);
        };
        const features = new ol.Feature({
            geometry: new ol.geom.Point(ol.proj.fromLonLat([116.4, 39.9])),
            type:"cricle1",
            status: 'active'
        });
        const features2 = new ol.Feature({
            geometry: new ol.geom.Point(ol.proj.fromLonLat([116.45, 39.901])),
            type:"cricle1",
            status: 'active'
        });
        const featureStyle=(feature,d,c)=>{
            const type = feature.get('type');
            const status = feature.get('status');
            let radiusNum=metersToPixels(currentRadius, map.getView().getResolution())
            // 创建渐变样式
           return new ol.style.Style({
                image: new ol.style.Circle({
                    radius: radiusNum,
                    fill: new ol.style.Fill({
                        color: (function() {
                            const canvas = document.createElement('canvas');
                            const ctx = canvas.getContext('2d');
                            const gradient = ctx.createRadialGradient(0,0,radiusNum/2,0,0,radiusNum);
                            gradient.addColorStop(0, 'rgba(0,255,255,0.1)');
                            gradient.addColorStop(1, 'rgba(0,100,255,0.2)');
                            return gradient;
                        })()
                    })
                })
            })
        }
        //feature.setStyle(featureStyle());
        let circleLayer=new ol.layer.Vector({
            source: new ol.source.Vector({
                features: [features,features2]
            }),
            style: featureStyle
        })
        

        // map.addLayer(vectorLayer);
        animate();
         

        
        
        map.addLayer(circleLayer)
        // 动画循环
        function animate() {
            currentRadius +=10;
            if (currentRadius >= maxRadius) {currentRadius= 0};
            
            //vectorLayer.getSource().changed();
            circleLayer.getSource().changed();// 强制刷新
            requestAnimationFrame(animate);
        }
    </script>
</body>
</html>
