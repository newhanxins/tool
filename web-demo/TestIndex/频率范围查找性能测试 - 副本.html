<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>性能对比 - 原生方法与优化方法</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            background-color: #f4f4f9;
        }
        h1 {
            text-align: center;
        }
        .result {
            margin: 20px 0;
            padding: 10px;
            border: 1px solid #ddd;
            background-color: #fff;
        }
        .comparison {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
        }
        .comparison div {
            width: 45%;
        }
        button {
            display: block;
            width: 200px;
            margin: 20px auto;
            padding: 10px;
            background-color: #007bff;
            color: white;
            font-size: 16px;
            cursor: pointer;
            border: none;
        }
        button:hover {
            background-color: #0056b3;
        }
        #chart-container {
            margin-top: 40px;
        }
        .performance-tip {
            text-align: center;
            margin-top: 20px;
            font-size: 18px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h1>性能对比 - 原生方法与优化方法</h1>
    <input id="data-size" type="number" value="10000" style="width: 100px;" /> 条数据
    <button id="run-tests">运行性能测试</button>

    <div class="result">
        <h2>原生方法</h2>
        <p id="native-time"></p>
        <p id="native-memory"></p>
    </div>

    <div class="result">
        <h2>优化方法1</h2>
        <p id="optimized-time"></p>
        <p id="optimized-memory"></p>
    </div>

    <div class="result">
        <h2>优化方法2（流式处理）</h2>
        <p id="optimized2-time"></p>
        <p id="optimized2-memory"></p>
    </div>

    <div class="result">
        <h2>优化方法3（分块处理）</h2>
        <p id="optimized3-time"></p>
        <p id="optimized3-memory"></p>
    </div>
    <div class="result">
        <h2>优化方法4</h2>
        <p id="optimized4-time"></p>
        <p id="optimized4-memory"></p>
    </div>
    <div id="chart-container">
        <canvas id="performanceChart"></canvas>
    </div>

    <div class="performance-tip" id="performance-tip"></div>

    <script>
        // 生成随机数据
        // function generateRandomData(size) {
        //     const data = [];
        //     for (let i = 0; i < size; i++) {
        //         const start_freq = Math.floor(Math.random() * 3000000000);
        //         const end_freq = start_freq + Math.floor(Math.random() * 1000000000);
        //         data.push({
        //             start_freq: start_freq,
        //             end_freq: end_freq,
        //             business: [{ business_id: Math.floor(Math.random() * 10) }]
        //         });
        //     }
        //     return data;
        // }

        // // 获取内存使用情况
        // function logMemoryUsage() {
        //     const memory = performance.memory;
        //     return `${(memory.usedJSHeapSize / (1024 * 1024)).toFixed(2)} MB`;
        // }

        // // 原生方法：排序并过滤
        // function filterData(data, startFreq, endFreq) {
        //     const start = performance.now();
        //     const filtered = data.sort((a, b) => a.start_freq - b.start_freq)
        //                          .filter(item => item.start_freq >= startFreq && item.end_freq <= endFreq);
        //     const end = performance.now();
        //     const timeTaken = end - start;
        //     const memoryUsage = logMemoryUsage();
        //     return { timeTaken, memoryUsage, filtered };
        // }

        // // 优化方法1：直接过滤
        // function optimizedFilterData(data, startFreq, endFreq) {
        //     const start = performance.now();
        //     const filtered = data.filter(item => item.start_freq >= startFreq && item.end_freq <= endFreq);
        //     const end = performance.now();
        //     const timeTaken = end - start;
        //     const memoryUsage = logMemoryUsage();
        //     return { timeTaken, memoryUsage, filtered };
        // }

        // // 优化方法2：流式处理（生成器）
        // function* streamFilterData(data, startFreq, endFreq) {
        //     for (let i = 0; i < data.length; i++) {
        //         const item = data[i];
        //         if (item.start_freq >= startFreq && item.end_freq <= endFreq) {
        //             yield item;
        //         }
        //     }
        // }

        // function optimizedFilterDataStream(data, startFreq, endFreq) {
        //     const start = performance.now();
        //     const filteredGenerator = streamFilterData(data, startFreq, endFreq);
        //     let filtered = [];
        //     let count = 0;
        //     for (let item of filteredGenerator) {
        //         filtered.push(item);
        //         count++;
        //     }
        //     const end = performance.now();
        //     const timeTaken = end - start;
        //     const memoryUsage = logMemoryUsage();
        //     return { timeTaken, memoryUsage, filtered };
        // }

        // // 优化方法3：分块处理
        // function chunkProcessData(data, startFreq, endFreq, chunkSize) {
        //     const start = performance.now();
        //     let filtered = [];
        //     let chunkCount = Math.ceil(data.length / chunkSize);

        //     for (let i = 0; i < chunkCount; i++) {
        //         const chunk = data.slice(i * chunkSize, (i + 1) * chunkSize);
        //         for (let item of chunk) {
        //             if (item.start_freq >= startFreq && item.end_freq <= endFreq) {
        //                 filtered.push(item);
        //             }
        //         }
        //         // 每处理完一个数据块，清理内存
        //         chunk.length = 0; // 清空数据块
        //     }
        //     const end = performance.now();
        //     const timeTaken = end - start;
        //     const memoryUsage = logMemoryUsage();
        //     return { timeTaken, memoryUsage, filtered };
        // }





        //es5 写法


        function generateRandomData(size) {
            var data = [];
            for (var i = 0; i < size; i++) {
                var start_freq = Math.floor(Math.random() * 3000000000);
                var end_freq = start_freq + Math.floor(Math.random() * 1000000000);
                data.push({
                    start_freq: start_freq,
                    end_freq: end_freq,
                    business: [{ business_id: Math.floor(Math.random() * 10) }]
                });
            }
            return data;
        }

        // 获取内存使用情况
        function logMemoryUsage() {
            var memory = performance.memory;
            return (memory.usedJSHeapSize / (1024 * 1024)).toFixed(2) + " MB";
        }

        // 原生方法：排序并过滤
        function filterData(data, startFreq, endFreq) {
            var start = performance.now();
            var filtered = data.sort(function(a, b) {
                return a.start_freq - b.start_freq;
            }).filter(function(item) {
                return item.start_freq >= startFreq && item.end_freq <= endFreq;
            });
            var end = performance.now();
            var timeTaken = end - start;
            var memoryUsage = logMemoryUsage();
            return { timeTaken: timeTaken, memoryUsage: memoryUsage, filtered: filtered };
        }

        // 优化方法1：直接过滤
        function optimizedFilterData(data, startFreq, endFreq) {
            var start = performance.now();
            var filtered = data.filter(function(item) {
                return item.start_freq >= startFreq && item.end_freq <= endFreq;
            });
            var end = performance.now();
            var timeTaken = end - start;
            var memoryUsage = logMemoryUsage();
            return { timeTaken: timeTaken, memoryUsage: memoryUsage, filtered: filtered };
        }

        // 优化方法2：流式处理（生成器）
        function* streamFilterData(data, startFreq, endFreq) {
            for (let i = 0; i < data.length; i++) {
                const item = data[i];
                if (item.start_freq >= startFreq && item.end_freq <= endFreq) {
                    yield item;
                }
            }
        }

        function optimizedFilterDataStream(data, startFreq, endFreq) {
            const start = performance.now();
            const filteredGenerator = streamFilterData(data, startFreq, endFreq);
            let filtered = [];
            let count = 0;
            for (let item of filteredGenerator) {
                filtered.push(item);
                count++;
            }
            const end = performance.now();
            const timeTaken = end - start;
            const memoryUsage = logMemoryUsage();
            return { timeTaken, memoryUsage, filtered };
        }

        // 优化方法3：分块处理
        function chunkProcessData(data, startFreq, endFreq, chunkSize) {
            var start = performance.now();
            var filtered = [];
            var chunkCount = Math.ceil(data.length / chunkSize);

            for (var i = 0; i < chunkCount; i++) {
                var chunk = data.slice(i * chunkSize, (i + 1) * chunkSize);
                for (var j = 0; j < chunk.length; j++) {
                    var item = chunk[j];
                    if (item.start_freq >= startFreq && item.end_freq <= endFreq) {
                        filtered.push(item);
                    }
                }
                // 每处理完一个数据块，清理内存
                chunk.length = 0; // 清空数据块
            }
            var end = performance.now();
            var timeTaken = end - start;
            var memoryUsage = logMemoryUsage();
            return { timeTaken: timeTaken, memoryUsage: memoryUsage, filtered: filtered };
        }


        function chunkProcessData4(data, startFreq, endFreq) {
            var start = performance.now();
            var sortedData = data.slice().sort(function(a, b) {
                return a.start_freq - b.start_freq;
            });

            // 2. 筛选重叠区间
            var filtered=[]
            for (let index = 0; index < sortedData.length; index++) {
                var item = sortedData[index];
                if(item.end_freq <startFreq){
                    // 如果当前区间的起始频率大于结束频率，说明后续区间都不可能重叠，直接跳出循环
                    continue;
                }else if(item.start_freq >= startFreq && item.end_freq <= endFreq){
                    filtered.push(item);
                }else if(item.start_freq > endFreq){
                    // 如果当前区间的起始频率大于结束频率，说明后续区间都不可能重叠，直接跳出循环
                    break;
                }
            }
            var end = performance.now();
            var timeTaken = end - start;
            var memoryUsage = logMemoryUsage();
            return { timeTaken: timeTaken, memoryUsage: memoryUsage, filtered: filtered };
        }

        // 性能测试
        function runPerformanceTests() {
            const dataSize = parseInt(document.getElementById('data-size').value) || 10000;
            const data = generateRandomData(dataSize);
            const startFreq = 1000000000;
            const endFreq = 2500000000;

            // 原生方法
            const nativeResult = filterData(data, startFreq, endFreq);
            document.getElementById('native-time').textContent = `执行时间：${nativeResult.timeTaken.toFixed(2)} 毫秒,过滤结果数量：${nativeResult.filtered.length}`;
            document.getElementById('native-memory').textContent = `内存使用：${nativeResult.memoryUsage}`;

            // 优化方法1
            const optimizedResult = optimizedFilterData(data, startFreq, endFreq);
            document.getElementById('optimized-time').textContent = `执行时间：${optimizedResult.timeTaken.toFixed(2)} 毫秒,过滤结果数量：${optimizedResult.filtered.length}`;
            document.getElementById('optimized-memory').textContent = `内存使用：${optimizedResult.memoryUsage}`;

            // 优化方法2（流式处理）
            const optimized2Result = optimizedFilterDataStream(data, startFreq, endFreq);
            document.getElementById('optimized2-time').textContent = `执行时间：${optimized2Result.timeTaken.toFixed(2)} 毫秒`;
            document.getElementById('optimized2-memory').textContent = `内存使用：${optimized2Result.memoryUsage}`;

            // 优化方法3（分块处理）
            const optimized3Result = chunkProcessData(data, startFreq, endFreq, 1000);
            document.getElementById('optimized3-time').textContent = `执行时间：${optimized3Result.timeTaken.toFixed(2)} 毫秒`;
            document.getElementById('optimized3-memory').textContent = `内存使用：${optimized3Result.memoryUsage}`;

            // 优化方法4（分块处理）
            const optimized4Result = chunkProcessData4(data, startFreq, endFreq, 1000);
            document.getElementById('optimized4-time').textContent = `执行时间：${optimized4Result.timeTaken.toFixed(2)} 毫秒`;
            document.getElementById('optimized4-memory').textContent = `内存使用：${optimized4Result.memoryUsage}`;
            // 绘制图表
            drawChart(nativeResult, optimizedResult, optimized2Result.timeTaken, optimized2Result.memoryUsage, optimized3Result.timeTaken, optimized3Result.memoryUsage,optimized4Result.timeTaken, optimized4Result.memoryUsage);
        }

        // 图表绘制
        function drawChart(nativeResult, optimizedResult, optimized2Time, optimized2Memory, optimized3Time, optimized3Memory,optimized4Time, optimized4Memory) {
            const ctx = document.getElementById('performanceChart').getContext('2d');
            const chart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['原生方法', '优化方法1', '优化方法2', '优化方法3','优化方法4'],
                    datasets: [{
                        label: '执行时间 (毫秒)',
                        data: [nativeResult.timeTaken, optimizedResult.timeTaken, optimized2Time, optimized3Time,optimized4Time],
                        backgroundColor: ['rgba(255, 99, 132, 0.2)', 'rgba(54, 162, 235, 0.2)', 'rgba(255, 159, 64, 0.2)', 'rgba(75, 192, 192, 0.2)','rgba(75, 192, 55, 0.2)'],
                        borderColor: ['rgba(255, 99, 132, 1)', 'rgba(54, 162, 235, 1)', 'rgba(255, 159, 64, 1)', 'rgba(75, 192, 192, 1)','rgba(75, 192, 182, 1)'],
                        borderWidth: 1
                    },
                    {
                        label: '内存使用 (MB)',
                        data: [parseFloat(nativeResult.memoryUsage), parseFloat(optimizedResult.memoryUsage), parseFloat(optimized2Memory), parseFloat(optimized3Memory),parseFloat(optimized4Memory)],
                        backgroundColor: ['rgba(153, 102, 255, 0.2)', 'rgba(75, 192, 192, 0.2)', 'rgba(255, 205, 86, 0.2)', 'rgba(153, 102, 255, 0.2)', 'rgba(153, 102, 245, 0.2)'],
                        borderColor: ['rgba(153, 102, 255, 1)', 'rgba(75, 192, 192, 1)', 'rgba(255, 205, 86, 1)', 'rgba(153, 102, 255, 1)', 'rgba(153, 102, 245, 1)'],
                        borderWidth: 1
                    }]
                },
                options: {
                    scales: {
                        y: {
                            beginAtZero: true
                        }
                    }
                }
            });
        }

        // 性能提示
        function showPerformanceTip(nativeResult, optimizedResult, optimized2Time, optimized2Memory, optimized3Time, optimized3Memory) {
            let tip = '';

            if (optimizedResult.timeTaken < nativeResult.timeTaken) {
                tip += '优化方法1在执行时间上更高效。\n';
            } else {
                tip += '原生方法在执行时间上表现更好。\n';
            }

            if (optimized2Time < optimizedResult.timeTaken) {
                tip += '优化方法2在执行时间上更高效（流式处理）。\n';
            }

            if (optimized3Time < optimized2Time) {
                tip += '优化方法3在执行时间上更高效（分块处理）。\n';
            }

            if (optimizedResult.memoryUsage < nativeResult.memoryUsage) {
                tip += '优化方法1在内存使用上更加节省。\n';
            } else {
                tip += '原生方法在内存使用上表现更好。\n';
            }

            if (optimized2Memory < optimizedResult.memoryUsage) {
                tip += '优化方法2在内存使用上更加节省。\n';
            }

            if (optimized3Memory < optimized2Memory) {
                tip += '优化方法3在内存使用上更加节省（分块处理）。\n';
            }

            document.getElementById('performance-tip').textContent = tip;
        }

        // 绑定按钮点击事件
        document.getElementById('run-tests').addEventListener('click', runPerformanceTests);
    </script>
</body>
</html>
