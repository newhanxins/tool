<!DOCTYPE html>
<html>
<head>
    <title>高性能Canvas交互完整版</title>
    <style>
        canvas { border: 1px solid #ccc; cursor: grab; }
        .debug-panel {
            position: fixed; top: 20px; right: 20px;
            background: rgba(0,0,0,0.8); color: #00ff00;
            padding: 12px; font-family: monospace; border-radius: 4px;
            user-select: none;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div class="debug-panel">
        <div>FPS: <span id="fps">0</span></div>
        <div>Visible: <span id="visible-count">0</span></div>
        <div>Memory: <span id="memory">N/A</span></div>
    </div>

<script>
// ================== 初始化阶段 ==================
var canvas = document.getElementById('canvas');
var ctx = canvas.getContext('2d');
var dpr = window.devicePixelRatio || 1;

// 高清适配
canvas.width = 800 * dpr;
canvas.height = 600 * dpr;
canvas.style.width = '800px';
canvas.style.height = '600px';
ctx.scale(dpr, dpr);

// ================== 数据生成 ==================
var RECT_COUNT = 100000;
var rectData = new Float32Array(RECT_COUNT * 6); // [x, y, w, h, hue, gridX, gridY]

for (var i = 0; i < RECT_COUNT; i++) {
    rectData.set([
        Math.random() * 4000,        // x
        Math.random() * 4000,        // y
        30 + Math.random() * 70,     // width
        30 + Math.random() * 70,     // height
        Math.random() * 360          // hue
    ], i * 6);
}

// ================== 空间索引 ==================
var GRID_SIZE = 200;
var gridMap = {};

function buildSpatialIndex() {
    for (var i = 0; i < RECT_COUNT; i++) {
        var x = rectData[i*6];
        var y = rectData[i*6+1];
        var gridX = Math.floor(x / GRID_SIZE);
        var gridY = Math.floor(y / GRID_SIZE);
        var key = gridX + '_' + gridY;
        
        if (!gridMap[key]) gridMap[key] = [];
        gridMap[key].push(i);
    }
}
buildSpatialIndex();

// ================== 视口控制 ==================
var viewport = {
    x: 0,
    y: 0,
    scale: 1,
    minScale: 0.1,
    maxScale: 5,
    width: 800,
    height: 600
};

// ================== 交互系统 ==================
var isDragging = false;
var lastPos = { x: 0, y: 0 };

// 鼠标事件
canvas.addEventListener('mousedown', function(e) {
    isDragging = true;
    lastPos = getCanvasPos(e);
    canvas.style.cursor = 'grabbing';
});

canvas.addEventListener('mousemove', function(e) {
    if (!isDragging) return;
    
    var pos = getCanvasPos(e);
    viewport.x += pos.x - lastPos.x;
    viewport.y += pos.y - lastPos.y;
    lastPos = pos;
});

document.addEventListener('mouseup', function() {
    isDragging = false;
    canvas.style.cursor = 'grab';
});

// 滚轮缩放
canvas.addEventListener('wheel', function(e) {
    e.preventDefault();
    var zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
    var mousePos = getCanvasPos(e);
    var worldPos = screenToWorld(mousePos);
    
    var newScale = viewport.scale * zoomFactor;
    newScale = Math.max(viewport.minScale, Math.min(newScale, viewport.maxScale));
    
    // 保持缩放中心
    viewport.x = mousePos.x - worldPos.x * newScale;
    viewport.y = mousePos.y - worldPos.y * newScale;
    viewport.scale = newScale;
});

// 坐标转换工具
function getCanvasPos(e) {
    var rect = canvas.getBoundingClientRect();
    return {
        x: (e.clientX - rect.left) * (canvas.width / rect.width) / dpr,
        y: (e.clientY - rect.top) * (canvas.height / rect.height) / dpr
    };
}

function screenToWorld(pos) {
    return {
        x: (pos.x - viewport.x) / viewport.scale,
        y: (pos.y - viewport.y) / viewport.scale
    };
}

// ================== 渲染系统 ==================
var visibleCache = [];
var frameCount = 0;
var lastFpsUpdate = Date.now();

function render() {
    ctx.clearRect(0, 0, viewport.width, viewport.height);
    
    // 可见性检测
    var visible = getVisibleRects();
    document.getElementById('visible-count').textContent = visible.length;
    
    // 批量绘制
    ctx.save();
    ctx.translate(viewport.x, viewport.y);
    ctx.scale(viewport.scale, viewport.scale);
    
    var batch = new Path2D();
    for (var i = 0; i < visible.length; i++) {
        var idx = visible[i];
        var x = rectData[idx*6];
        var y = rectData[idx*6+1];
        var w = rectData[idx*6+2];
        var h = rectData[idx*6+3];
        ctx.fillStyle = 'hsl(' + rectData[idx*6+4] + ',70%,50%)';
        ctx.fillRect(x, y, w, h);
    }
    
    ctx.restore();
    
    // 更新统计
    frameCount++;
    if (Date.now() - lastFpsUpdate > 1000) {
        document.getElementById('fps').textContent = Math.round(frameCount / ((Date.now() - lastFpsUpdate)/1000));
        frameCount = 0;
        lastFpsUpdate = Date.now();
    }
    requestAnimationFrame(render);
}

function getVisibleRects() {
    var visible = [];
    var invScale = 1 / viewport.scale;
    var left = -viewport.x * invScale;
    var right = (-viewport.x + viewport.width) * invScale;
    var top = -viewport.y * invScale;
    var bottom = (-viewport.y + viewport.height) * invScale;
    
    // 空间索引查询
    var startX = Math.max(0, Math.floor(left / GRID_SIZE) - 1);
    var endX = Math.ceil(right / GRID_SIZE) + 1;
    var startY = Math.max(0, Math.floor(top / GRID_SIZE) - 1);
    var endY = Math.ceil(bottom / GRID_SIZE) + 1;
    
    for (var x = startX; x <= endX; x++) {
        for (var y = startY; y <= endY; y++) {
            var key = x + '_' + y;
            if (gridMap[key]) {
                visible.push.apply(visible, gridMap[key]);
            }
        }
    }
    
    // 精确检测
    return visible.filter(function(idx) {
        var rectX = rectData[idx*6];
        var rectY = rectData[idx*6+1];
        var rectW = rectData[idx*6+2];
        var rectH = rectData[idx*6+3];
        return rectX < right && rectX + rectW > left && rectY < bottom && rectY + rectH > top;
    });
}

// ================== 启动系统 ==================
render();
</script>
</body>
</html>
