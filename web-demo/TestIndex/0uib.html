<!DOCTYPE html>
<html>
<head>
  <style>
    /* 保持原有样式不变 */
    #container {
      width: 100%;
      height: 600px;
      overflow: auto;
      border: 1px solid #ddd;
    }
    #timeline {
      display: block;
    }
    .tooltip {
      position: fixed;
      background: rgba(255,255,255,0.9);
      padding: 8px 12px;
      border-radius: 4px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="container">
    <canvas id="timeline"></canvas>
  </div>
  <div id="tooltip" class="tooltip"></div>

  <script>
class TimelineVisualizer {
  constructor(containerId, canvasId) {
    // 配置参数
    this.config = {
      baseWidth: 1200,
      axisRange: [0, 300],
      axisHeight: 50,
      trackHeight: 45,
      padding: 3,
      minUnitWidth: 4,
      maxUnitWidth: 20
    };

    // 状态管理
    this.state = {
      scale: 1,
      offsetX: 0,
      events: this.generateDemoEvents(),
      draggedEvent: null
    };

    // DOM元素
    this.container = document.getElementById(containerId);
    this.canvas = document.getElementById(canvasId);
    this.ctx = this.canvas.getContext('2d');
    this.tooltip = document.getElementById('tooltip');

    // 初始化
    this.initCanvasSize();
    this.bindEvents();
    this.render();
  }

  // 初始化方法
  initCanvasSize() {
    this.canvas.width = this.container.clientWidth;
    this.canvas.height = this.container.clientHeight;
  }

  updateCanvasSize(trackCount) {
    const totalHeight = this.config.axisHeight + trackCount * this.config.trackHeight;
    this.canvas.height = totalHeight;
    this.canvas.width = this.config.baseWidth * this.state.scale;
  }

  // 核心布局算法
  layoutEvents(events) {
    const tracks = [];
    const sorted = [...events].sort((a, b) => 
      a.startValue - b.startValue || (a.endValue - a.startValue) - (b.endValue - b.startValue)
    );

    sorted.forEach(event => {
      let placed = false;
      for (const track of tracks) {
        const lastEvent = track[track.length - 1];
        if (event.startValue >= lastEvent.endValue) {
          track.push(event);
          placed = true;
          break;
        }
      }
      if (!placed) tracks.push([event]);
    });

    return tracks;
  }

  // 渲染流程
  render() {
    const tracks = this.layoutEvents(this.state.events);
    this.updateCanvasSize(tracks.length);
    
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.drawValueAxis();
    this.drawTracks(tracks);
  }

  // 轴系统绘制
  drawValueAxis() {
    this.ctx.save();
    this.ctx.font = '14px system-ui';
    const [minVal, maxVal] = this.config.axisRange;
    const visibleStart = this.xToValue(-this.state.offsetX);
    const visibleEnd = this.xToValue(-this.state.offsetX + this.container.clientWidth);

    // 主刻度
    for (let value = Math.ceil(visibleStart / 50) * 50; value <= visibleEnd; value += 50) {
      const x = this.valueToX(value);
      this.ctx.beginPath();
      this.ctx.moveTo(x, 0);
      this.ctx.lineTo(x, 15);
      this.ctx.strokeStyle = '#666';
      this.ctx.stroke();
      this.ctx.fillStyle = '#333';
      this.ctx.fillText(value, x + 4, 30);
    }

    // 次刻度
    for (let value = Math.ceil(visibleStart / 10) * 10; value <= visibleEnd; value += 10) {
      const x = this.valueToX(value);
      this.ctx.beginPath();
      this.ctx.moveTo(x, 0);
      this.ctx.lineTo(x, 8);
      this.ctx.strokeStyle = '#999';
      this.ctx.stroke();
    }

    this.ctx.beginPath();
    this.ctx.moveTo(0, this.config.axisHeight);
    this.ctx.lineTo(this.canvas.width, this.config.axisHeight);
    this.ctx.strokeStyle = '#444';
    this.ctx.stroke();
    this.ctx.restore();
  }

  // 轨道绘制
  drawTracks(tracks) {
    const visibleStartX = -this.state.offsetX;
    const visibleEndX = visibleStartX + this.container.clientWidth;

    tracks.forEach((track, index) => {
      const yBase = this.config.axisHeight + index * this.config.trackHeight;
      
      // 轨道背景
      this.ctx.fillStyle = index % 2 === 0 ? '#f8f8f8' : '#fff';
      this.ctx.fillRect(0, yBase, this.canvas.width, this.config.trackHeight);

      track.forEach(event => {
        const xStart = this.valueToX(event.startValue);
        const xEnd = this.valueToX(event.endValue);
        
        if (xEnd < visibleStartX || xStart > visibleEndX) return;

        const width = xEnd - xStart;
        this.ctx.fillStyle = event.color;
        this.ctx.roundRect(xStart, yBase + this.config.padding, width, 
                     this.config.trackHeight - this.config.padding * 2, 6);
        this.ctx.fill();

        if (width > 40) {
          this.ctx.fillStyle = '#fff';
          this.ctx.font = '12px system-ui';
          this.ctx.textBaseline = 'middle';
          this.ctx.fillText(
            `${event.startValue.toFixed(1)}-${event.endValue.toFixed(1)}`,
            xStart + 8,
            yBase + this.config.trackHeight / 2
          );
        }
      });
    });
  }

  // 坐标转换
  valueToX(value) {
    const [minVal, maxVal] = this.config.axisRange;
    const range = maxVal - minVal;
    const ratio = (value - minVal) / range;
    return ratio * this.config.baseWidth * this.state.scale + this.state.offsetX;
  }

  xToValue(x) {
    const [minVal, maxVal] = this.config.axisRange;
    const range = maxVal - minVal;
    const denominator = this.config.baseWidth * this.state.scale;
    
    if (denominator <= 0) return minVal;
    
    const ratio = (x - this.state.offsetX) / denominator;
    return minVal + ratio * range;
  }

  // 事件绑定
  bindEvents() {
    let isDragging = false;
    let startX = 0;

    // 画布拖拽
    this.canvas.addEventListener('mousedown', e => {
      isDragging = true;
      startX = e.clientX;
    });

    window.addEventListener('mousemove', e => {
      if (isDragging) {
        this.state.offsetX += (e.clientX - startX) * 0.5;
        startX = e.clientX;
        this.state.offsetX = Math.min(0, Math.max(
          this.state.offsetX, 
          this.canvas.width - this.container.clientWidth
        ));
        this.throttledRender();
      }
    });

    window.addEventListener('mouseup', () => isDragging = false);

    // 事件拖拽
    this.canvas.addEventListener('mousedown', e => {
      const rect = this.canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      
      this.state.draggedEvent = this.findEventAt(x, y);
      if (this.state.draggedEvent) {
        const duration = this.state.draggedEvent.endValue - this.state.draggedEvent.startValue;
        this.state.draggedEvent.minValue = this.config.axisRange;
        this.state.draggedEvent.maxValue = this.config.axisRange - duration;
      }
    });

    window.addEventListener('mousemove', e => {
      if (this.state.draggedEvent) {
        const rect = this.canvas.getBoundingClientRect();
        const rawX = e.clientX - rect.left;
        const newStart = Math.max(this.state.draggedEvent.minValue, 
          Math.min(this.xToValue(rawX), this.state.draggedEvent.maxValue));
        
        const duration = this.state.draggedEvent.endValue - this.state.draggedEvent.startValue;
        this.state.draggedEvent.startValue = newStart;
        this.state.draggedEvent.endValue = newStart + duration;
        this.throttledRender();
      }
    });

    window.addEventListener('mouseup', () => {
      this.state.draggedEvent = null;
    });

    // 缩放控制
    this.container.addEventListener('wheel', e => {
      const rect = this.canvas.getBoundingClientRect();
      const centerX = e.clientX - rect.left;
      const centerValue = this.xToValue(centerX);
      
      const delta = e.deltaY > 0 ? 0.9 : 1.1;
      this.state.scale = Math.min(
        this.config.maxUnitWidth / (this.config.baseWidth / 300), 
        Math.max(
          this.config.minUnitWidth / (this.config.baseWidth / 300), 
          this.state.scale * delta
        )
      );
      
      // 保持缩放中心
      const newCenterX = this.valueToX(centerValue);
      this.state.offsetX += (centerX - newCenterX);
      
      this.throttledRender();
      e.preventDefault();
    }, { passive: false });

    // 悬浮提示
    this.canvas.addEventListener('mousemove', e => {
      const rect = this.canvas.getBoundingClientRect();
      const event = this.findEventAt(e.clientX - rect.left, e.clientY - rect.top);
      
      if (event) {
        this.tooltip.style.display = 'block';
        this.tooltip.style.left = `${e.pageX + 15}px`;
        this.tooltip.style.top = `${e.pageY + 15}px`;
        this.tooltip.innerHTML = `<strong>${event.title}</strong><br>
          Value: ${event.startValue.toFixed(1)} - ${event.endValue.toFixed(1)}`;
      } else {
        this.tooltip.style.display = 'none';
      }
    });

    // 性能优化
    this.throttledRender = this.throttle(this.render.bind(this), 100);
  }

  // 工具方法
  findEventAt(x, y) {
    const value = this.xToValue(x);
    const tracks = this.layoutEvents(this.state.events);
    
    for (const [trackIndex, track] of tracks.entries()) {
      const yStart = this.config.axisHeight + trackIndex * this.config.trackHeight;
      const yEnd = yStart + this.config.trackHeight;
      
      if (y >= yStart && y <= yEnd) {
        for (const event of track) {
          if (value >= event.startValue && value <= event.endValue) {
            return event;
          }
        }
      }
    }
    return null;
  }

  generateDemoEvents() {
    const events = [];
    const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4'];
    for (let i = 0; i < 12; i++) {
      const start = Math.random() * 250;
      const duration = 10 + Math.random() * 40;
      events.push({
        title: `Event ${i + 1}`,
        startValue: start,
        endValue: Math.min(start + duration, 300),
        color: colors[i % colors.length]
      });
    }
    return events;
  }

  throttle(fn, delay) {
    let lastCall = 0;
    return (...args) => {
      const now = Date.now();
      if (now - lastCall >= delay) {
        fn(...args);
        lastCall = now;
      }
    };
  }
}

// 初始化时间轴可视化
new TimelineVisualizer('container', 'timeline');
  </script>
</body>
</html>
