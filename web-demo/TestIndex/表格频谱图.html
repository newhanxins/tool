<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Interactive Map with Canvas</title>
  <style>
    canvas {
      border: 1px solid #000;
      display: block;
      margin: 0 auto;
    }
  </style>
</head>
<body>

<canvas id="myCanvas" width="800" height="600"></canvas>

<script>
// 获取 canvas 元素和上下文
const canvas = document.getElementById('myCanvas');
const ctx = canvas.getContext('2d');

// 示例数据：省份和市区的坐标 (假设为矩形区域，实际应用可根据数据调整)
const areas = [
  { id: 1, name: 'City 1', x: 50, y: 50, width: 150, height: 100 },
  { id: 2, name: 'City 1111111111111111111111111111112', x: 200, y: 50, width: 150, height: 30 },
  { id: 3, name: 'City 3', x: 50, y: 150, width: 150, height: 100 },
  { id: 4, name: 'City 4', x: 200, y: 150, width: 150, height: 100 },
  { id: 5, name: '水上移动', x: 200, y: 350, width: 150, height: 100 },
];

let selectedArea = null;
let offsetX = 0, offsetY = 0;
let scaleX = 1, scaleY = 1; // X轴和Y轴分别独立缩放
let scaleDirection = 'both'; // 缩放方向，'x'：只缩放X轴，'y'：只缩放Y轴，'both'：同时缩放X轴和Y轴

// 绘制地图
function drawMap() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);  // 清空画布
  
  // 绘制所有区域
  areas.forEach(area => {
    // 根据缩放比例调整区域位置和尺寸
    const x = area.x * scaleX + offsetX;
    const y = area.y * scaleY + offsetY;
    const width = area.width * scaleX;
    const height = area.height * scaleY;

    // 绘制区域矩形
    ctx.fillStyle = 'rgba(0, 150, 255, 0.5)';
    ctx.fillRect(x, y, width, height);

    // 绘制区域边框
    ctx.strokeStyle = 'blue';
    ctx.lineWidth = 2;
    ctx.strokeRect(x, y, width, height);

    // 绘制文字
    drawText(area, x, y, width, height);
  });

  // 高亮选中的区域
  if (selectedArea) {
    ctx.strokeStyle = 'red';
    ctx.lineWidth = 3;
    const x = selectedArea.x * scaleX + offsetX;
    const y = selectedArea.y * scaleY + offsetY;
    const width = selectedArea.width * scaleX;
    const height = selectedArea.height * scaleY;
    ctx.strokeRect(x, y, width, height);
  }
}

// 绘制区域中的文字
function drawText(area, x, y, width, height) {
  const fontSize = 16;
  ctx.font = `${fontSize}px Arial`;
  ctx.fillStyle = 'black';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  const text = area.name;
  const textWidth = ctx.measureText(text).width;

  // 文字显示方式
  if (width >= textWidth) {
    // 如果宽度足够，一行显示文字并居中
    ctx.fillText(text, x + width / 2, y + height / 2);
  } else if (width >= fontSize * 2) {
    // 如果宽度不足以显示一行文字但足够显示两行
    const lineHeight = fontSize * 1.2;
    const maxLines = Math.floor(height / lineHeight);
    const lines = splitText(text, width,maxLines);
    
    const totalHeight = lines.length * lineHeight;
    let startY = y + height / 2 - totalHeight / 2+lineHeight/2;

    lines.forEach((line, index) => {
      ctx.fillText(line, x + width / 2, startY + index * lineHeight);
    });
  } else {
    // 如果宽度不足以显示两行文字，文字竖直显示
    const maxHeight = height - 10; // 留点边距
    const maxLines = Math.floor(maxHeight / fontSize);
    if(maxLines==0){
      return;
    }
    const lines = splitText(text, fontSize, maxLines);

    let startY = y + height / 2 - lines.length * fontSize / 2;
    lines.forEach((line, index) => {
      ctx.fillText(line, x + width / 2, startY + index * fontSize);
    });
  }
}

// 处理文本的拆分
function splitText(text, maxWidth, maxLines = Infinity) {
  const lines = [];
  let currentLine = '';

  for (let i = 0; i < text.length; i++) {
    const testLine = currentLine + text[i];
    const testWidth = ctx.measureText(testLine).width;

    if (testWidth > maxWidth) {
      if (currentLine.length > 0) {
        lines.push(currentLine);
      }
      currentLine = text[i]; // Start new line with the current character
    } else {
      currentLine = testLine;
    }

    if (lines.length >= maxLines) {
      break;
    }
  }

  if (currentLine.length > 0) {
    lines.push(currentLine);
  }
  if(maxLines==0){
    lines.splice(0);
  }
  // 如果行数超过最大行数，截断并添加省略号
  if (lines.length > maxLines) {
    lines[maxLines - 1] = lines[maxLines - 1].slice(0, -1) + '...';
    // 删除多余的行
    lines.splice(maxLines);
  }

  return lines;
}

// 检查点击是否在区域内
function checkClick(x, y) {
  return areas.find(area => {
    const areaX = area.x * scaleX + offsetX;
    const areaY = area.y * scaleY + offsetY;
    const areaWidth = area.width * scaleX;
    const areaHeight = area.height * scaleY;
    return x >= areaX && x <= areaX + areaWidth && y >= areaY && y <= areaY + areaHeight;
  });
}

// 处理鼠标点击事件
canvas.addEventListener('click', (e) => {
  const mouseX = e.offsetX;
  const mouseY = e.offsetY;
  const clickedArea = checkClick(mouseX, mouseY);
  if (clickedArea) {
    selectedArea = clickedArea;
    drawMap(); // 重新绘制地图并高亮选中区域
  } else {
    selectedArea = null;
    drawMap(); // 重新绘制地图并去掉高亮
  }
});

// 处理鼠标滚轮缩放
canvas.addEventListener('wheel', (e) => {
  e.preventDefault();  // 阻止默认滚动行为
  const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;  // 放大或缩小
console.log(zoomFactor,scaleDirection)
  if (scaleDirection === 'x' || scaleDirection === 'both') {
    scaleX *= zoomFactor;  // 调整X轴的缩放比例
  }
  if (scaleDirection === 'y' || scaleDirection === 'both') {
    scaleY *= zoomFactor;  // 调整Y轴的缩放比例
  }

  // 防止缩放过小或过大
  if (scaleX < 0.5) scaleX = 0.5;
  if (scaleX > 3) scaleX = 3;
  if (scaleY < 0.5) scaleY = 0.5;
  if (scaleY > 3) scaleY = 3;

  drawMap();  // 重新绘制地图
});

// 处理拖动功能
let isDragging = false;
let startX = 0;
let startY = 0;

canvas.addEventListener('mousedown', (e) => {
  isDragging = true;
  startX = e.offsetX - offsetX;
  startY = e.offsetY - offsetY;
});

canvas.addEventListener('mousemove', (e) => {
  if (isDragging) {
    offsetX = e.offsetX - startX;
    offsetY = e.offsetY - startY;
    drawMap();  // 重新绘制地图
  }
});

canvas.addEventListener('mouseup', () => {
  isDragging = false;
});

canvas.addEventListener('mouseleave', () => {
  isDragging = false;
});

// 手指触摸操作
let touchStartDist = 0;
let prevTouchDistance = 0;
let isTouching = false;

canvas.addEventListener('touchstart', (e) => {
  if (e.touches.length == 2) {
    isTouching = true;
    const touch1 = e.touches[0];
    const touch2 = e.touches[1];
    touchStartDist = Math.hypot(touch2.pageX - touch1.pageX, touch2.pageY - touch1.pageY);
    prevTouchDistance = touchStartDist;
  }
});

canvas.addEventListener('touchmove', (e) => {
  if (isTouching && e.touches.length == 2) {
    const touch1 = e.touches[0];
    const touch2 = e.touches[1];
    const touchDist = Math.hypot(touch2.pageX - touch1.pageX, touch2.pageY - touch1.pageY);

    // 计算触摸移动的缩放因子
    const scaleChange = touchDist / prevTouchDistance;
    if (scaleDirection === 'x' || scaleDirection === 'both') {
      scaleX *= scaleChange;
    }
    if (scaleDirection === 'y' || scaleDirection === 'both') {
      scaleY *= scaleChange;
    }

    // 防止缩放过小或过大
    if (scaleX < 0.5) scaleX = 0.5;
    if (scaleX > 3) scaleX = 3;
    if (scaleY < 0.5) scaleY = 0.5;
    if (scaleY > 3) scaleY = 3;

    // 更新触摸的上一距离
    prevTouchDistance = touchDist;
    drawMap();  // 重新绘制地图
  }
});

canvas.addEventListener('touchend', () => {
  if (e.touches.length < 2) {
    isTouching = false;
    prevTouchDistance = 0;
  }
});
// 通过键盘切换缩放方向
window.addEventListener('keydown', (e) => {
  if (e.key === 'x') {
    scaleDirection = 'x'; // 只缩放X轴
  } else if (e.key === 'y') {
    scaleDirection = 'y'; // 只缩放Y轴
  } else if (e.key === 'b') {
    scaleDirection = 'both'; // 同时缩放X轴和Y轴
  }
});
// 初始绘制地图
drawMap();
</script>

</body>
</html>
