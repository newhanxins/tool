<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>OpenLayers 绘制扇形</title>
  <!-- 引入 OpenLayers 的 CSS 文件 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@latest/dist/ol.css" type="text/css">
  <style>
    #map {
      width: 100%;
      height: 80vh;
    }
    #controls {
      padding: 20px;
    }
  </style>
</head>
<body>
  <div id="controls">
    <label for="startAngle">开始角度（度）：</label>
    <input type="number" id="startAngle" value="-45" step="1">
    <br>
    <label for="endAngle">结束角度（度）：</label>
    <input type="number" id="endAngle" value="45" step="1">
    <br>
    <label for="lengthNum">扇形长度：</label>
    <input type="number" id="lengthNum" value="20" step="1">
    <br>
    <button onclick="drawSector()">绘制扇形</button>
    <button onclick="randomLine()">随机绘制扇形</button>
    <button onclick="twoLine()">维度生成扇形</button>
    <br>
    <button onclick="clearSectors()">清除所有扇形</button>
    <br>
    <button onclick="drawLineAtAngle()">绘制30度的线段</button>
  </div>
  <div id="map"></div>

  <script src="https://cdn.jsdelivr.net/npm/ol@latest/dist/ol.js"></script>
  <script>
    // 创建地图对象，设置地图目标容器、图层和视图
    let map=""
 
    map = new ol.Map({
      target: 'map',
      layers: [
        new ol.layer.Tile({
          source: new ol.source.XYZ({
            url: 'http://wprd0{1-4}.is.autonavi.com/appmaptile?lang=zh_cn&size=1&style=7&x={x}&y={y}&z={z}'
          }),
        }),
      ],
      view: new ol.View({
        center: ol.proj.fromLonLat([103, 30]),  // 设置地图中心为 (103, 30)
        zoom: 6,  // 设置地图缩放级别
        //rotation: Math.PI / 6  // 设置旋转角度，例如45度
      }),
    });

// 创建一个空的向量图层，用来保存扇形
const sectorLayer = new ol.layer.Vector({
            source: new ol.source.Vector(),
        });
        map.addLayer(sectorLayer);
    /**
     * 计算扇形的边界点
     * @param {Array} center 扇形的中心点
     * @param {number} radius 扇形的半径
     * @param {number} startAngle 起始角度
     * @param {number} endAngle 结束角度
     * @param {number} segments 扇形的分段数
     * @returns {Array} 扇形的边界点数组
     */
    function createSector(center, radius, startAngle, endAngle, segments) {
      console.log("计算点参数",center, radius, startAngle, endAngle, segments)
      const points = [];
      let pointarr=[]
      //const center = ol.proj.fromLonLat(centers);
      const step = (endAngle - startAngle) / segments;
      for (let angle = startAngle; angle <= endAngle; angle += step) {
        console.log("angle",angle)
        let angLine= angle* Math.PI / 180
        const lon = center[0] + radius * Math.sin(angLine);
        const lat = center[1] + radius * Math.cos(angLine);
        const mercatorCoord = ol.proj.fromLonLat([lon, lat]); // 转换为 Web Mercator 坐标
        points.push(mercatorCoord);
        pointarr.push([lon,lat])
      }
      // 将中心点也转换为 Web Mercator 坐标
      const centerMercator = ol.proj.fromLonLat(center);
      points.push(centerMercator);
      pointarr.push(center)
      console.log("扇形点",pointarr)
      return points;
    }
    function createSectors(center, radius, startAngle, endAngle, segments) {
      const points = [];
      
      const step = (endAngle - startAngle) / segments;
      for (let angle = startAngle; angle <= endAngle; angle += step) {
        console.log("angle",angle)
        const lon = center[0] + radius * Math.sin(angle);
        const lat = center[1] + radius * Math.cos(angle);
        const mercatorCoord = ol.proj.fromLonLat([lon, lat]); // 转换为 Web Mercator 坐标
        if(!isNaN(mercatorCoord[0])&&!isNaN(mercatorCoord[1])){
          points.push(mercatorCoord);
        }
        
      }
      // 将中心点也转换为 Web Mercator 坐标
      const centerMercator = ol.proj.fromLonLat(center);
      points.push(centerMercator);
      console.log("扇形点",points)
      return points;
    }

    // 绘制扇形
    function drawSector() {
      const center = [103, 30];  // 扇形的中心经纬度坐标
      const startAngle = parseFloat(document.getElementById('startAngle').value) * Math.PI / 180;  // 开始角度（度转弧度）
      const endAngle = parseFloat(document.getElementById('endAngle').value) * Math.PI / 180;     // 结束角度（度转弧度）
      const radiusNum = parseFloat(document.getElementById('lengthNum').value)// 半径（单位：度，表示大约 55 公里）
      var pixelDistance=ol.sphere.getDistance([center[0],85], center)
      console.log("距离",pixelDistance)
      const sectorPoints = createSectors(center, radiusNum, startAngle, endAngle, 30);
      drawline(sectorPoints);
    }
    function randomLine(){
      const radiusNum = getRandomAngleoffset(10, 30);  // 扇形的半径
      const coordinates = getRandomCoordinates();
      const centerangles = getRandomAngleoffset(0, 360);
      const offsetAngle = getRandomAngleoffset(90, 360)/2;
      const centerCoord=calculateSectorAngles(centerangles,offsetAngle)
      const segments=Math.round(centerangles/1)+3// 扇形的分段数
      
      
      const sectorPoints = createSector(coordinates, radiusNum, centerCoord.startAngle, centerCoord.endAngle, segments);
      drawline(sectorPoints);
    }
    function twoLine(){
      const center = [103, 30];  // 扇形的中心经纬度坐标
      const startAngle = parseFloat(document.getElementById('startAngle').value);  // 开始角度（度转弧度）
      const endAngle = parseFloat(document.getElementById('endAngle').value);     // 结束角度（度转弧度）
      var pixelDistance=ol.sphere.getDistance([center[0],85], center)
      console.log("距离",pixelDistance)
      //线像素长度
      var lengthnum = map.getSize()[0] * 3;//无限长默认长度
      console.log("长度地图大小三倍",lengthnum)
      var initlinelen=2000;
      initlinelen=pixelDistance;
      var zoom = map.getView().getZoom();
      var mapzoomtran = 1.42 * Math.pow(2, zoom - 1);
      var length = 111319.5 * initlinelen / mapzoomtran;
      var coorall = ol.proj.transform(center, "EPSG:4326", "EPSG:3857")
      var points=[]
      var step=(endAngle-startAngle)/10
      var x=coorall[0]
      var y=coorall[1]
      for (var angle = startAngle; angle <= endAngle; angle += step) {
        var tha = tharate(angle)
        var toX = length * Math.cos(tha * Math.PI / 180) + x,
        toY = length * Math.sin(tha * Math.PI / 180) + y;
        points.push([toX,toY])
        var tocoor = ol.proj.transform([toX, toY], "EPSG:3857", "EPSG:4326")
        console.log("to",tocoor)
      }
      points.push(coorall)
      console.log("第二种方式扇形点",points)
      drawline(points);
    }
    function drawline(sectorPoints){
      console.log("扇形点",sectorPoints)
      const polygon = new ol.geom.Polygon([sectorPoints]);
      const sectorFeature = new ol.Feature(polygon);
      const rgbaColor = getRandomRGBAColor();


      const featureStyle = new ol.style.Style({
          fill: new ol.style.Fill({
            color: rgbaColor,
          }),
          stroke: new ol.style.Stroke({
            color: '#ff0000',
            width: 2,
          }),
      });
      sectorFeature.setStyle(featureStyle);
      sectorLayer.getSource().addFeature(sectorFeature);
    }
// 清除所有扇形
function clearSectors() {
            sectorLayer.getSource().clear();
        }

    // 生成随机坐标，经度范围 103 到 104，纬度范围 30 到 31
    function getRandomCoordinates() {
            const longitude = (Math.random() * (104 - 103)) + 103; // 随机经度
            const latitude = (Math.random() * (31 - 30)) + 30;   // 随机纬度
            return [longitude,latitude];
        }

        // 生成随机角度，起始角度和结束角度
        function getRandomAngles() {
            const startAngle = Math.random() * 360; // 随机起始角度（-180 到 180 度）
            let endAngle = Math.random() * 360;     // 随机结束角度（-180 到 180 度）
            // 确保结束角度大于起始角度
            if (endAngle < startAngle) {
                endAngle = startAngle + (Math.random() * 360); // 保证结束角度大于起始角度
            }
            return { startAngle, endAngle };
        }

        // 函数：生成指定范围内的随机整数角度
        function getRandomAngleoffset(min, max) {
            // 生成一个在 [min, max] 范围内的随机浮动值
            const randomValue = Math.random() * (max - min) + min;
            
            // 将随机值四舍五入并返回整数
            return Math.round(randomValue);
        }
        // 生成随机RGBA颜色
        function getRandomRGBAColor() {
            const r = Math.floor(Math.random() * 256); // 随机红色
            const g = Math.floor(Math.random() * 256); // 随机绿色
            const b = Math.floor(Math.random() * 256); // 随机蓝色
            const a = (Math.random()).toFixed(2);     // 随机透明度（0-1）
            return `rgba(${r}, ${g}, ${b}, ${a})`;
        }

        // 函数：将角度归一化到 0 到 360 范围内
        function normalizeAngle(angle) {
            // 对角度进行模 360 运算，确保角度在 -360 到 360 之间
            angle = angle % 360;
            
            // 如果角度为负，确保它在 0 到 360 范围内（通过加 360）
            if (angle < 0) {
                angle += 360;
            }
            
            // 返回归一化后的角度
            return angle;
        }

        // 函数：计算扇形的起始角度和结束角度
        function calculateSectorAngles(centerAngle, offsetAngle) {
            // 计算起始角度：中心角度减去偏移量，并归一化到 0 到 360 范围内
            const startAngle = (centerAngle - offsetAngle)*Math.PI / 180;
            
            // 计算结束角度：中心角度加上偏移量，并归一化到 0 到 360 范围内
            const endAngle = (centerAngle + offsetAngle)*Math.PI / 180;
            // 返回计算出的起始角度和结束角度
            return { startAngle, endAngle };
        }
    // 绘制指定角度的线段
    function drawLineAtAngle() {
        const center = [103, 30];  // 线段的起点
        const length = 10;  // 线段长度
        const angle = 45;  // 线段的角度（30度）
      const angleRad = angle * Math.PI / 180;  // 将角度转换为弧度
      const endLon = center[0] + length * Math.cos(angleRad);
      const endLat = center[1] + length * Math.sin(angleRad);

      // 计算终点的墨卡托坐标
      const startMercator = ol.proj.fromLonLat(center);
      const endMercator = ol.proj.fromLonLat([endLon, endLat]);

      const line = new ol.geom.LineString([startMercator, endMercator]);
      const lineFeature = new ol.Feature(line);

      const vectorSource = new ol.source.Vector({
        features: [lineFeature],
      });

      const vectorLayer = new ol.layer.Vector({
        source: vectorSource,
        style: new ol.style.Style({
          stroke: new ol.style.Stroke({
            color: '#0000FF',  // 蓝色线段
            width: 3,
          }),
        }),
      });

      map.addLayer(vectorLayer);
    }
    //角度转换
function tharate(nm) {
    var number;
    if (nm < 90) {
        var ra = 360 - (90 - nm); //转为顺时针角度
    } else {
        var ra = nm - 90; //转为顺时针角度
    }
    number = 360 - ra;
    return number
}
  </script>
</body>
</html>
