<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenLayers角度测量(可编辑)</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol/ol.css">
    <style>
        #map {
            width: 100%;
            height: 100vh;
        }
        .control-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 0 15px rgba(0,0,0,0.2);
            z-index: 1;
        }
        .angle-display {
            font-size: 1.2em;
            margin-top: 10px;
            padding: 8px;
            background: #f0f0f0;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <div class="control-panel">
        <button id="start">开始测量</button>
        <button id="clear">清除</button>
        <div class="angle-display">角度: <span id="angle-value">--</span>°</div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/ol@v5.3.0/dist/ol.js"></script>
    <script>
        const map = new ol.Map({
            target: 'map',
            layers: [
                new ol.layer.Tile({
                    source: new ol.source.OSM()
                })
            ],
            view: new ol.View({
                center: ol.proj.fromLonLat([116.404, 39.915]),
                zoom: 12
            })
        });

        const vectorSource = new ol.source.Vector();
        const vectorLayer = new ol.layer.Vector({
            source: vectorSource,
            style: function(feature) {
                const type = feature.getGeometry().getType();
                if (type === 'Point') {
                    const name = feature.get('name');
                    return new ol.style.Style({
                        image: new ol.style.Circle({
                            radius: 6,
                            fill: new ol.style.Fill({ color: 'red' }),
                            stroke: new ol.style.Stroke({ color: 'white', width: 2 })
                        }),
                        text: new ol.style.Text({
                            text: name,
                            fill: new ol.style.Fill({ color: '#000' }),
                            stroke: new ol.style.Stroke({ color: '#fff', width: 2 }),
                            offsetY: -15
                        })
                    });
                } else if (type === 'LineString') {
                    const name = feature.get('name');
                    const color = name === 'Line AB' ? 'red' : 'blue';
                    return new ol.style.Style({
                        stroke: new ol.style.Stroke({
                            color: color,
                            width: 3
                        })
                    });
                } else {
                    return new ol.style.Style({
                        stroke: new ol.style.Stroke({
                            color: 'green',
                            width: 2,
                            lineDash: [5, 5]
                        })
                    });
                }
            }
        });
        map.addLayer(vectorLayer);

        let drawInteraction, modifyInteraction;
        const points = [];
        let pointFeatures = [];
        let lineFeatures = [];
        let arcFeature = null;
        
        document.getElementById('start').addEventListener('click', function() {
            clearMeasurements();
            drawInteraction = new ol.interaction.Draw({
                type: 'Point',
                source: vectorSource
            });

            drawInteraction.on('drawend', function(evt) {
                const feature = evt.feature;
                const coord = feature.getGeometry().getCoordinates();
                points.push(coord);
                
                if (points.length === 1) {
                    feature.set('name', 'A');
                    pointFeatures[0] = feature;
                } else if (points.length === 2) {
                    feature.set('name', 'B');
                    pointFeatures[1] = feature;
                    
                    // 绘制第一条线
                    const lineAB = new ol.geom.LineString([points[0], points[1]]);
                    const lineABFeature = new ol.Feature({
                        geometry: lineAB,
                        name: 'Line AB'
                    });
                    vectorSource.addFeature(lineABFeature);
                    lineFeatures[0] = lineABFeature;
                } else if (points.length === 3) {
                    feature.set('name', 'C');
                    pointFeatures[2] = feature;
                    
                    // 绘制第二条线
                    const lineBC = new ol.geom.LineString([points[1], points[2]]);
                    const lineBCFeature = new ol.Feature({
                        geometry: lineBC,
                        name: 'Line BC'
                    });
                    vectorSource.addFeature(lineBCFeature);
                    lineFeatures[1] = lineBCFeature;
                    
                    // 计算角度
                    updateAngle();
                    
                    // 添加修改交互
                    addModifyInteraction();
                    
                    map.removeInteraction(drawInteraction);
                }
            });

            map.addInteraction(drawInteraction);
        });

        document.getElementById('clear').addEventListener('click', clearMeasurements);

        function clearMeasurements() {
            vectorSource.clear();
            points.length = 0;
            pointFeatures = [];
            lineFeatures = [];
            arcFeature = null;
            document.getElementById('angle-value').textContent = '--';
            if (drawInteraction) {
                map.removeInteraction(drawInteraction);
            }
            if (modifyInteraction) {
                map.removeInteraction(modifyInteraction);
            }
        }

        function addModifyInteraction() {
            modifyInteraction = new ol.interaction.Modify({
                source: vectorSource,
                features: new ol.Collection(pointFeatures)
            });
            
            modifyInteraction.on('modifyend', function(evt) {
                const features = evt.features.getArray();
                features.forEach(feature => {
                    const name = feature.get('name');
                    const index = name.charCodeAt(0) - 65; // A=0, B=1, C=2
                    points[index] = feature.getGeometry().getCoordinates();
                    
                    // 更新连线
                    if (index === 0 && lineFeatures[0]) {
                        lineFeatures[0].getGeometry().setCoordinates([points[0], points[1]]);
                    } else if (index === 1 && lineFeatures[0] && lineFeatures[1]) {
                        lineFeatures[0].getGeometry().setCoordinates([points[0], points[1]]);
                        lineFeatures[1].getGeometry().setCoordinates([points[1], points[2]]);
                    } else if (index === 2 && lineFeatures[1]) {
                        lineFeatures[1].getGeometry().setCoordinates([points[1], points[2]]);
                    }
                });
                
                updateAngle();
            });
            
            map.addInteraction(modifyInteraction);
        }

        function updateAngle() {
            const angle = calculateClockwiseAngle(points);
            document.getElementById('angle-value').textContent = angle.toFixed(2);
            
            // 更新弧线
            if (arcFeature) {
                vectorSource.removeFeature(arcFeature);
            }
            drawAngleArc(points[1], points[0], points[2], angle);
        }

        function calculateClockwiseAngle(points) {
            const [A, B, C] = points;
            
            // 计算向量BA和BC
            const BA = [A[0] - B[0], A[1] - B[1]];
            const BC = [C[0] - B[0], C[1] - B[1]];
            
            // 计算向量BA的方位角（从正北顺时针）
            const angleBA = (Math.atan2(BA[0], BA[1]) + 2 * Math.PI) % (2 * Math.PI);
            
            // 计算向量BC的方位角（从正北顺时针）
            const angleBC = (Math.atan2(BC[0], BC[1]) + 2 * Math.PI) % (2 * Math.PI);
            
            // 计算顺时针角度差（修正340度问题）
            let angle = (angleBC - angleBA) * (180 / Math.PI);
            if (angle < 0) angle += 360;
            
            // 处理340度显示为20度的问题
            if (angle > 180) {
                angle = 360 - angle;
                // 交换起点和终点
                const temp = angleBA;
                angleBA = angleBC;
                angleBC = temp;
            }
            
            return angle;
        }

        function drawAngleArc(center, start, end, angle) {
            const radius = Math.min(
                Math.sqrt(Math.pow(start[0] - center[0], 2) + Math.pow(start[1] - center[1], 2)) * 0.3,
                Math.sqrt(Math.pow(end[0] - center[0], 2) + Math.pow(end[1] - center[1], 2)) * 0.3
            );
            
            // 计算起始角度（从正北顺时针）
            let startAngle = (Math.atan2(start[0] - center[0], start[1] - center[1]) + 2 * Math.PI) % (2 * Math.PI);
            let endAngle = (Math.atan2(end[0] - center[0], end[1] - center[1]) + 2 * Math.PI) % (2 * Math.PI);
            
            // 处理大角度情况
            if (endAngle < startAngle) {
                endAngle += 2 * Math.PI;
            }
            
            // 创建弧线点集
            const arcPoints = [];
            const steps = 20;
            for (let i = 0; i <= steps; i++) {
                const t = i / steps;
                const currentAngle = startAngle + t * (endAngle - startAngle);
                const x = center[0] + radius * Math.sin(currentAngle);
                const y = center[1] + radius * Math.cos(currentAngle);
                arcPoints.push([x, y]);
            }
            
            // 添加弧线特征
            arcFeature = new ol.Feature({
                geometry: new ol.geom.LineString(arcPoints),
                name: 'Angle Arc'
            });
            vectorSource.addFeature(arcFeature);
        }
    </script>
</body>
</html>
